{"version":3,"sources":["js/multicolor_series.js"],"names":["factory","module","exports","Highcharts","H","getPath","arr","ret","each","el","concat","seriesTypes","pick","hasTouch","UNDEFINED","document","documentElement","ontouchstart","TRACKER_FILL","hasSVG","Series","prototype","getSegmentPath","H.Series.prototype.getSegmentPath","segment","series","segmentPath","step","options","point","i","plotX","plotY","getPointSpline","push","apply","L","M","lastPoint","coloredline","extendClass","line","processData","H.seriesTypes.coloredline.prototype.processData","force","processedXData","xData","processedYData","yData","closestPointRange","xAxis","isCartesian","isDirty","yAxis","length","distance","requireSorting","window","console","log","msg","cropped","cropStart","pointRange","drawTracker","H.seriesTypes.coloredline.prototype.drawTracker","trackByArea","trackerPath","areaPath","graphPath","trackerPathLength","chart","pointer","renderer","snap","tooltip","tracker","cursor","css","singlePoints","onMouseOver","hoverSeries","splice","singlePoint","attr","d","path","visibility","visible","VISIBLE","HIDDEN","stroke","fill","NONE","lineWidth","zIndex","add","group","markerGroup","track","addClass","on","e","onTrackerMouseOut","setState","H.seriesTypes.coloredline.prototype.setState","state","graph","stateOptions","states","attribs","NORMAL_STATE","enabled","dashstyle","seg","getSegments","H.seriesTypes.coloredline.prototype.getSegments","lastColor","segments","points","pointsLength","connectNulls","y","j","segmentColor","slice","color","previousColor","colorChanged","colorExists","segmetColor","p","pointObject","k","next","getGraphPath","H.seriesTypes.coloredline.prototype.getGraphPath","drawGraph","H.seriesTypes.coloredline.prototype.drawGraph","getSegment","prop","dashStyle","roundCap","shadow","item","props","lineColor","linecap","graphPathLength","graphSegmentsLength","graphKey","g","destroy","wrap","proceed","call","arguments","coloredarea","init","H.seriesTypes.coloredarea.prototype.init","threshold","closeSegment","H.seriesTypes.coloredarea.prototype.closeSegment","translatedThreshold","H.seriesTypes.coloredarea.prototype.drawGraph","f","H.seriesTypes.coloredarea.prototype.getSegmentPath","closePath","areaSegmentPath","segLength","getThreshold","stacking","closedStacks","yBottom","H.seriesTypes.coloredarea.prototype.getGraphPath","shouldClosePath","drawLegendSymbol","LegendSymbolMixin","drawRectangle"],"mappings":"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","file":"multicolor_series.min.js","sourceRoot":"/source/","sourcesContent":["/**\n* Multicolor Series v2.2.1-0(2016-06-24)\n*\n* (c) 2012-2016 Black Label\n*\n* License: Creative Commons Attribution (CC)\n*/\n/* global Highcharts window document module:true */\n/**\n * @fileoverview\n * @suppress {checkTypes}\n */\n(function (factory) {\n\tif (typeof module === 'object' && module.exports) {\n\t\tmodule.exports = factory;\n\t} else {\n\t\tfactory(Highcharts);\n\t}\n}(function (H) {\n\tvar each = H.each,\n\t\tseriesTypes = H.seriesTypes,\n\t\tpick = H.pick,\n\t\tUNDEFINED,\n\t\tNORMAL_STATE = '',\n\t\tVISIBLE = 'visible',\n\t\tHIDDEN = 'hidden',\n\t\tPREFIX = 'highcharts-',\n\t\tNONE = 'none',\n\t\thasTouch = document.documentElement.ontouchstart !== UNDEFINED,\n\t\tTRACKER_FILL = 'rgba(192,192,192,' + (H.hasSVG ? 0.0001 : 0.002) + ')', // invisible but clickable\n\t\tM = 'M',\n\t\tL = 'L';\n\n\t// handle unsorted data, throw error anyway\n\tfunction error(code, stop) {\n\t\tvar msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\n\t\tif (stop) {\n\t\t\tthrow msg;\n\t\t} else if (window.console) {\n\t\t\tconsole.log(msg); // eslint-disable-line\n\t\t}\n\t}\n\n\t/**\n\tIf replacing L and M in tracker will be necessary use that getPath():\n\n\tfunction getPath(arr){\n\tvar ret = [];\n\teach(arr, function(el, ind) {\n\tvar len = el[0].length;\n\tfor(var i = 0; i < len; i++){\n\tvar p = el[0][i];\n\tif(p == M && ind != 0 && i == 0) {\n\tp = L;\n\t}\n\tret.push(p);\n\t}\n\t});\n\treturn ret;\n\t}\n\t**/\n\n\n\tfunction getPath(arr) {\n\t\tvar ret = [];\n\t\teach(arr, function (el) {\n\t\t\tret = ret.concat(el[0]);\n\t\t});\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Return the graph path of a segment - compatibility with 4.2.3+\n\t * @param {object} segment of the path\n\t * @returns {array} Path (SVG)\n\t */\n\tH.Series.prototype.getSegmentPath = function (segment) {\n\t\tvar series = this,\n\t\t\tsegmentPath = [],\n\t\t\tstep = series.options.step;\n\n\t\t// build the segment line\n\t\teach(segment, function (point, i) {\n\t\t\tvar plotX = point.plotX,\n\t\t\t\tplotY = point.plotY,\n\t\t\t\tlastPoint;\n\n\t\t\tif (series.getPointSpline) {\n\t\t\t\t// generate the spline as defined in the SplineSeries object\n\t\t\t\tsegmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));\n\t\t\t} else {\n\t\t\t\t// moveTo or lineTo\n\t\t\t\tsegmentPath.push(i ? L : M);\n\n\t\t\t\t// step line?\n\t\t\t\tif (step && i) {\n\t\t\t\t\tlastPoint = segment[i - 1];\n\t\t\t\t\tif (step === 'right') {\n\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\tlastPoint.plotX,\n\t\t\t\t\t\t\tplotY,\n\t\t\t\t\t\t\tL\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (step === 'center') {\n\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\n\t\t\t\t\t\t\tlastPoint.plotY,\n\t\t\t\t\t\t\tL,\n\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\n\t\t\t\t\t\t\tplotY,\n\t\t\t\t\t\t\tL\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\tplotX,\n\t\t\t\t\t\t\tlastPoint.plotY,\n\t\t\t\t\t\t\tL\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// normal line to next point\n\t\t\t\tsegmentPath.push(\n\t\t\t\t\tpoint.plotX,\n\t\t\t\t\tpoint.plotY\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\treturn segmentPath;\n\t};\n\n\t/**\n\t*\n\t*   ColoredLine series type\n\t*\n\t**/\n\n\tseriesTypes.coloredline = H.extendClass(seriesTypes.line);\n\n\tH.seriesTypes.coloredline.prototype.processData = function (force) {\n\t\tvar series = this,\n\t\t\tprocessedXData = series.xData, // copied during slice operation below\n\t\t\tprocessedYData = series.yData,\n\t\t\tcropStart = 0,\n\t\t\tcropped,\n\t\t\tdistance,\n\t\t\tclosestPointRange,\n\t\t\txAxis = series.xAxis,\n\t\t\ti, // loop variable\n\t\t\toptions = series.options,\n\t\t\tisCartesian = series.isCartesian;\n\n\t\t// If the series data or axes haven't changed, don't go through this. Return false to pass\n\t\t// the message on to override methods like in data grouping.\n\t\tif (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Find the closest distance between processed points\n\t\tfor (i = processedXData.length - 1; i >= 0; i--) {\n\t\t\tdistance = processedXData[i] - processedXData[i - 1];\n\t\t\tif (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\n\t\t\t\tclosestPointRange = distance;\n\n\t\t\t\t// Unsorted data is not supported by the line tooltip, as well as data grouping and\n\t\t\t\t// navigation in Stock charts (#725) and width calculation of columns (#1900)\n\t\t\t} else if (distance < 0 && series.requireSorting) {\n\t\t\t\terror(15);\n\t\t\t}\n\t\t}\n\n\t\t// Record the properties\n\t\tseries.cropped = cropped; // undefined or true\n\t\tseries.cropStart = cropStart;\n\t\tseries.processedXData = processedXData;\n\t\tseries.processedYData = processedYData;\n\n\t\tif (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC\n\t\t\tseries.pointRange = closestPointRange || 1;\n\t\t}\n\t\tseries.closestPointRange = closestPointRange;\n\t\treturn true;\n\t};\n\n\tH.seriesTypes.coloredline.prototype.drawTracker = function () {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\ttrackByArea = options.trackByArea,\n\t\t\ttrackerPath = [].concat(trackByArea ? series.areaPath : getPath(series.graphPath)),\n\t\t\ttrackerPathLength = trackerPath.length,\n\t\t\tchart = series.chart,\n\t\t\tpointer = chart.pointer,\n\t\t\trenderer = chart.renderer,\n\t\t\tsnap = chart.options.tooltip.snap,\n\t\t\ttracker = series.tracker,\n\t\t\tcursor = options.cursor,\n\t\t\tcss = cursor && { cursor: cursor },\n\t\t\tsinglePoints = series.singlePoints,\n\t\t\tsinglePoint,\n\t\t\ti,\n\t\t\tonMouseOver;\n\n\t\tonMouseOver = function () {\n\t\t\tif (chart.hoverSeries !== series) {\n\t\t\t\tseries.onMouseOver();\n\t\t\t}\n\t\t};\n\t\t// Extend end points. A better way would be to use round linecaps,\n\t\t// but those are not clickable in VML.\n\t\tif (trackerPathLength && !trackByArea) {\n\t\t\ti = trackerPathLength + 1;\n\t\t\twhile (i--) {\n\t\t\t\tif (trackerPath[i] === M) { // extend left side\n\t\t\t\t\ttrackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\n\t\t\t\t}\n\t\t\t\tif ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\n\t\t\t\t\ttrackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// handle single points\n\t\tfor (i = 0; i < singlePoints.length; i++) {\n\t\t\tsinglePoint = singlePoints[i];\n\t\t\tif (singlePoint.plotX && singlePoint.plotY) {\n\t\t\t\ttrackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n\t\t\t\t\tL, singlePoint.plotX + snap, singlePoint.plotY);\n\t\t\t}\n\t\t}\n\n\t\t// draw the tracker\n\t\tif (tracker) {\n\t\t\ttracker.attr({ d: trackerPath });\n\t\t} else { // create\n\t\t\tseries.tracker = renderer.path(trackerPath)\n\t\t\t.attr({\n\t\t\t\t'stroke-linejoin': 'round', // #1225\n\t\t\t\tvisibility: series.visible ? VISIBLE : HIDDEN,\n\t\t\t\tstroke: TRACKER_FILL,\n\t\t\t\tfill: trackByArea ? TRACKER_FILL : NONE,\n\t\t\t\t'stroke-width': options.lineWidth + (trackByArea ? 0 : 2 * snap),\n\t\t\t\tzIndex: 2\n\t\t\t})\n\t\t\t.add(series.group);\n\n\t\t\t// The tracker is added to the series group, which is clipped, but is covered\n\t\t\t// by the marker group. So the marker group also needs to capture events.\n\t\t\teach([series.tracker, series.markerGroup], function (track) {\n\t\t\t\ttrack.addClass(PREFIX + 'tracker')\n\t\t\t\t.on('mouseover', onMouseOver)\n\t\t\t\t.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\n\t\t\t\t.css(css);\n\n\t\t\t\tif (hasTouch) {\n\t\t\t\t\ttrack.on('touchstart', onMouseOver);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t};\n\n\tH.seriesTypes.coloredline.prototype.setState = function (state) {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tgraph = series.graph,\n\t\t\tstateOptions = options.states,\n\t\t\tlineWidth = options.lineWidth,\n\t\t\tattribs;\n\n\t\tstate = state || NORMAL_STATE;\n\n\t\tif (series.state !== state) {\n\t\t\tseries.state = state;\n\n\t\t\tif (stateOptions[state] && stateOptions[state].enabled === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (state) {\n\t\t\t\tlineWidth = stateOptions[state].lineWidth || lineWidth + 1;\n\t\t\t}\n\n\t\t\tif (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n\t\t\t\tattribs = {\n\t\t\t\t\t'stroke-width': lineWidth\n\t\t\t\t};\n\t\t\t\t// use attr because animate will cause any other animation on the graph to stop\n\t\t\t\teach(graph, function (seg) {\n\t\t\t\t\tseg.attr(attribs);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* The main change to get multi color isFinite changes segments array.\n\t* From array of points to object with color and array of points.\n\t* @returns {undefined}\n\t**/\n\tH.seriesTypes.coloredline.prototype.getSegments = function () {\n\t\tvar series = this,\n\t\t\tlastColor = 0,\n\t\t\tsegments = [],\n\t\t\ti,\n\t\t\tpoints = series.points,\n\t\t\tpointsLength = points.length;\n\n\t\tif (pointsLength) { // no action required for []\n\n\t\t\t// if connect nulls, just remove null points\n\t\t\tif (series.options.connectNulls) {\n\t\t\t\t// iterate backwars for secure point removal\n\t\t\t\tfor (i = pointsLength - 1; i >= 0; --i) {\n\t\t\t\t\tif (points[i].y === null) {\n\t\t\t\t\t\tpoints.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointsLength = points.length;\n\n\t\t\t\teach(points, function (point, j) {\n\t\t\t\t\tif (j > 0 && points[j].segmentColor !== points[j - 1].segmentColor) {\n\t\t\t\t\t\tsegments.push({\n\t\t\t\t\t\t\tpoints: points.slice(lastColor, j + 1),\n\t\t\t\t\t\t\tcolor: points[j - 1].segmentColor\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlastColor = j;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// add the last segment (only single-point last segement is added)\n\t\t\t\tif (lastColor !== pointsLength - 1) {\n\t\t\t\t\tsegments.push({\n\t\t\t\t\t\tpoints: points.slice(lastColor, pointsLength),\n\t\t\t\t\t\tcolor: points[pointsLength - 1].segmentColor\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (points.length && segments.length === 0) {\n\t\t\t\t\tsegments = [points];\n\t\t\t\t}\n\n\t\t\t\t// else, split on null points or different colors\n\t\t\t} else {\n\t\t\t\tvar previousColor = null;\n\t\t\t\teach(points, function (point, j) {\n\t\t\t\t\tvar colorChanged = j > 0 && (point.y === null || points[j - 1].y === null || (point.segmentColor !== points[j - 1].segmentColor && points[j].segmentColor !== previousColor)),\n\t\t\t\t\t\tcolorExists = points[j - 1] && points[j - 1].segmentColor && points[j - 1].y !== null ? true : false;\n\n\t\t\t\t\t// handle first point\n\t\t\t\t\tif (!previousColor && point.segmetColor) {\n\t\t\t\t\t\tpreviousColor = point.segmentColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (colorChanged) {\n\t\t\t\t\t\tvar p = points.slice(lastColor, j + 1);\n\t\t\t\t\t\tif (p.length > 0) {\n\t\t\t\t\t\t\t// do not create segments with null ponits\n\t\t\t\t\t\t\teach(p, function (pointObject, k) {\n\t\t\t\t\t\t\t\tif (pointObject.y === null) {\n\t\t\t\t\t\t\t\t\t// remove null points (might be on edges)\n\t\t\t\t\t\t\t\t\tp.splice(k, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tsegments.push({\n\t\t\t\t\t\t\t\tpoints: p,\n\t\t\t\t\t\t\t\tcolor: colorExists ? points[j - 1].segmentColor : previousColor\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlastColor = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (j === pointsLength - 1) {\n\t\t\t\t\t\tvar next = j + 1;\n\t\t\t\t\t\tif (point.y === null) {\n\t\t\t\t\t\t\tnext--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp = points.slice(lastColor, next);\n\t\t\t\t\t\tif (p.length > 0) {\n\t\t\t\t\t\t\t// do not create segments with null ponits\n\t\t\t\t\t\t\teach(p, function (pointObject, k) {\n\t\t\t\t\t\t\t\tif (pointObject.y === null) {\n\t\t\t\t\t\t\t\t\t// remove null points (might be on edges)\n\t\t\t\t\t\t\t\t\tp.splice(k, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tsegments.push({\n\t\t\t\t\t\t\t\tpoints: p,\n\t\t\t\t\t\t\t\tcolor: colorExists ? points[j - 1].segmentColor : previousColor\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlastColor = j;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// store previous color\n\t\t\t\t\tif (point) {\n\t\t\t\t\t\tpreviousColor = point.segmentColor;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// register it\n\t\tseries.segments = segments;\n\t};\n\n\tH.seriesTypes.coloredline.prototype.getGraphPath = function () {\n\t\t// var ret = f.apply(this, Array.prototype.slice.call(arguments, 1));\n\t\tvar series = this,\n\t\t\tgraphPath = [],\n\t\t\tsegmentPath,\n\t\t\tsinglePoints = []; // used in drawTracker\n\t\t// Divide into segments and build graph and area paths\n\t\teach(series.segments, function (segment) {\n\t\t\tsegmentPath = series.getSegmentPath(segment.points);\n\t\t\t// add the segment to the graph, or a single point for tracking\n\t\t\tif (segment.points.length > 1) {\n\t\t\t\tgraphPath.push([segmentPath, segment.color]);\n\t\t\t} else {\n\t\t\t\tsinglePoints.push(segment.points);\n\t\t\t}\n\t\t});\n\n\t\t// Record it for use in drawGraph and drawTracker, and return graphPath\n\t\tseries.singlePoints = singlePoints;\n\t\tseries.graphPath = graphPath;\n\n\t\treturn graphPath;\n\t};\n\n\tH.seriesTypes.coloredline.prototype.drawGraph = function () {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tprops = [['graph', options.lineColor || series.color]],\n\t\t\tlineWidth = options.lineWidth,\n\t\t\tdashStyle = options.dashStyle,\n\t\t\troundCap = options.linecap !== 'square',\n\t\t\tgraphPath = series.getGraphPath(),\n\t\t\tgraphPathLength = graphPath.length,\n\t\t\tgraphSegmentsLength = 0;\n\n\t\tfunction getSegment(segment, prop, i) {\n\t\t\tvar attribs = {\n\t\t\t\t\tstroke: prop[1],\n\t\t\t\t\t'stroke-width': lineWidth,\n\t\t\t\t\tzIndex: 1 // #1069\n\t\t\t\t},\n\t\t\t\titem;\n\t\t\tif (dashStyle) {\n\t\t\t\tattribs.dashstyle = dashStyle;\n\t\t\t} else if (roundCap) {\n\t\t\t\tattribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n\t\t\t}\n\t\t\tif (segment[1]) {\n\t\t\t\tattribs.stroke = segment[1];\n\t\t\t}\n\n\t\t\titem = series.chart.renderer.path(segment[0])\n\t\t\t.attr(attribs)\n\t\t\t.add(series.group)\n\t\t\t.shadow(!i && options.shadow);\n\n\t\t\treturn item;\n\t\t}\n\n\t\t// draw the graph\n\t\teach(props, function (prop, i) {\n\t\t\tvar graphKey = prop[0],\n\t\t\t\tgraph = series[graphKey],\n\t\t\t\tg;\n\n\t\t\tif (graph) { // cancel running animations, #459\n\t\t\t\t// do we have animation\n\t\t\t\teach(graphPath, function (segment, j) {\n\t\t\t\t\t// update color and path\n\n\t\t\t\t\tif (series[graphKey][j]) {\n\t\t\t\t\t\tseries[graphKey][j].attr({ d: segment[0], stroke: segment[1] });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tseries[graphKey][j] = getSegment(segment, prop, i);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else if (lineWidth && graphPath.length) { // #1487\n\t\t\t\tgraph = [];\n\t\t\t\teach(graphPath, function (segment, j) {\n\t\t\t\t\tgraph[j] = getSegment(segment, prop, i);\n\t\t\t\t});\n\t\t\t\tseries[graphKey] = graph;\n\t\t\t\t// add destroying elements\n\t\t\t\tseries[graphKey].destroy = function () {\n\t\t\t\t\tfor (g in series[graphKey]) {  // eslint-disable-line\n\t\t\t\t\t\tvar el = series[graphKey][g];\n\t\t\t\t\t\tif (el && el.destroy) {\n\t\t\t\t\t\t\tel.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Checks if series.graph exists. #3\n\t\t\tgraphSegmentsLength = (series.graph && series.graph.length) || -1;\n\n\t\t\tfor (var j = graphSegmentsLength; j >= graphPathLength; j--) {\n\t\t\t\tif (series[graphKey][j]) {\n\t\t\t\t\tseries[graphKey][j].destroy();\n\t\t\t\t\tseries[graphKey].splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tH.wrap(seriesTypes.coloredline.prototype, 'translate', function (proceed) {\n\t\tproceed.apply(this, [].slice.call(arguments, 1));\n\t\tif (this.getSegments) {\n\t\t\tthis.getSegments();\n\t\t}\n\t});\n\n\n\n\t/**\n\t*\n\t*   ColoredArea series type\n\t*\n\t**/\n\tseriesTypes.coloredarea = H.extendClass(seriesTypes.coloredline);\n\n\tH.seriesTypes.coloredarea.prototype.init = function (chart, options) {\n\t\toptions.threshold = options.threshold || null;\n\t\tH.Series.prototype.init.call(this, chart, options);\n\t};\n\n\tH.seriesTypes.coloredarea.prototype.closeSegment = function (path, segment, translatedThreshold) {\n\t\tpath.push(\n\t\t\tL,\n\t\t\tsegment[segment.length - 1].plotX,\n\t\t\ttranslatedThreshold,\n\t\t\tL,\n\t\t\tsegment[0].plotX,\n\t\t\ttranslatedThreshold\n\t\t);\n\t};\n\n\tH.seriesTypes.coloredarea.prototype.drawGraph = function (f) {\n\t\tH.seriesTypes.coloredline.prototype.drawGraph.call(this, f);\n\t\tvar series = this,\n\t\t\toptions = this.options,\n\t\t\tprops = [['graph', options.lineColor || series.color]];\n\n\t\teach(props, function (prop) {\n\t\t\tvar graphKey = prop[0],\n\t\t\t\tgraph = series[graphKey];\n\n\t\t\tif (graph) { // cancel running animations, #459\n\t\t\t\t// do we have animation\n\t\t\t\teach(series.graphPath, function (segment, j) {\n\t\t\t\t\t// update color and path\n\n\t\t\t\t\tif (series[graphKey][j]) {\n\t\t\t\t\t\tseries[graphKey][j].attr({ fill: segment[1] });\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t* Extend the base Series getSegmentPath method by adding the path for the area.\n\t* This path is pushed to the series.areaPath property.\n\t* @param {object} segment of the path\n\t* @param {boolean} closePath indicates if the path should be closed\n\t* @returns {array} Path (SVG)\n\t**/\n\tH.seriesTypes.coloredarea.prototype.getSegmentPath = function (segment, closePath) {\n\t\tvar segmentPath = H.Series.prototype.getSegmentPath.call(this, segment), // call base method\n\t\t\tareaSegmentPath = [].concat(segmentPath), // work on a copy for the area path\n\t\t\ti,\n\t\t\toptions = this.options,\n\t\t\tsegLength = segmentPath.length,\n\t\t\ttranslatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181\n\t\t\tyBottom;\n\n\t\tclosePath = closePath || true; // close the path by default\n\n\t\tif (segLength === 3) { // for animation from 1 to two points\n\t\t\tareaSegmentPath.push(L, segmentPath[1], segmentPath[2]);\n\t\t}\n\t\tif (options.stacking && !this.closedStacks) {\n\t\t\tfor (i = segment.length - 1; i >= 0; i--) {\n\n\t\t\t\tyBottom = pick(segment[i].yBottom, translatedThreshold);\n\n\t\t\t\t// step line?\n\t\t\t\tif (i < segment.length - 1 && options.step) {\n\t\t\t\t\tareaSegmentPath.push(segment[i + 1].plotX, yBottom);\n\t\t\t\t}\n\t\t\t\tareaSegmentPath.push(segment[i].plotX, yBottom);\n\t\t\t}\n\t\t} else if (closePath) { // follow zero line back\n\t\t\tthis.closeSegment(areaSegmentPath, segment, translatedThreshold);\n\t\t}\n\t\treturn areaSegmentPath;\n\t};\n\n\tH.seriesTypes.coloredarea.prototype.getGraphPath = function () {\n\t\tvar series = this,\n\t\t\tgraphPath = [],\n\t\t\tsegmentPath,\n\t\t\tsinglePoints = []; // used in drawTracker\n\t\t// Divide into segments and build graph and area paths\n\n\t\tthis.areaPath = [];\n\t\teach(series.segments, function (segment) {\n\t\t\tvar shouldClosePath = !!segment.color;\n\t\t\tsegmentPath = series.getSegmentPath(segment.points, shouldClosePath);\n\t\t\t// add the segment to the graph, or a single point for tracking\n\t\t\tif (segment.points.length > 1) {\n\t\t\t\tgraphPath.push([segmentPath, segment.color]);\n\t\t\t} else {\n\t\t\t\tsinglePoints.push(segment.points);\n\t\t\t}\n\t\t});\n\n\t\t// Record it for use in drawGraph and drawTracker, and return graphPath\n\t\tseries.singlePoints = singlePoints;\n\t\tseries.graphPath = graphPath;\n\t\treturn graphPath;\n\n\t};\n\n\tH.seriesTypes.coloredarea.prototype.drawLegendSymbol = H.LegendSymbolMixin.drawRectangle;\n}));"]}