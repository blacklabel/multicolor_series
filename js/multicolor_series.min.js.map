{"version":3,"sources":["js/multicolor_series.js"],"names":["factory","module","exports","Highcharts","H","getPath","arr","ret","each","el","concat","seriesTypes","pick","hasTouch","UNDEFINED","document","documentElement","ontouchstart","TRACKER_FILL","hasSVG","Series","prototype","getSegmentPath","H.Series.prototype.getSegmentPath","segment","series","segmentPath","step","options","point","i","plotX","plotY","getPointSpline","push","apply","L","M","lastPoint","coloredline","extendClass","line","processData","H.seriesTypes.coloredline.prototype.processData","force","processedXData","xData","processedYData","yData","closestPointRange","xAxis","isCartesian","isDirty","yAxis","length","distance","requireSorting","window","console","log","msg","cropped","cropStart","pointRange","drawTracker","H.seriesTypes.coloredline.prototype.drawTracker","trackByArea","trackerPath","areaPath","graphPath","trackerPathLength","chart","pointer","renderer","snap","tooltip","tracker","cursor","css","singlePoints","onMouseOver","hoverSeries","splice","singlePoint","attr","d","path","visibility","visible","VISIBLE","HIDDEN","stroke","fill","NONE","lineWidth","zIndex","add","group","markerGroup","track","addClass","on","e","onTrackerMouseOut","setState","H.seriesTypes.coloredline.prototype.setState","state","graph","stateOptions","states","attribs","NORMAL_STATE","enabled","dashstyle","seg","getSegments","H.seriesTypes.coloredline.prototype.getSegments","lastColor","segments","points","pointsLength","connectNulls","y","j","segmentColor","slice","color","previousColor","colorExists","p","pointObject","k","next","getGraphPath","H.seriesTypes.coloredline.prototype.getGraphPath","drawGraph","H.seriesTypes.coloredline.prototype.drawGraph","getSegment","prop","dashStyle","roundCap","item","shadow","props","lineColor","linecap","graphPathLength","graphSegmentsLength","graphKey","g","destroy","wrap","proceed","call","arguments","coloredarea","init","H.seriesTypes.coloredarea.prototype.init","threshold","closeSegment","H.seriesTypes.coloredarea.prototype.closeSegment","translatedThreshold","H.seriesTypes.coloredarea.prototype.drawGraph","f","H.seriesTypes.coloredarea.prototype.getSegmentPath","areaSegmentPath","segLength","getThreshold","stacking","closedStacks","yBottom","H.seriesTypes.coloredarea.prototype.getGraphPath","drawLegendSymbol","LegendSymbolMixin","drawRectangle"],"mappings":"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","file":"multicolor_series.min.js","sourceRoot":"/source/","sourcesContent":["/**\n* Multicolor Series v2.2.2(2017-09-29)\n*\n* (c) 2012-2016 Black Label\n*\n* License: Creative Commons Attribution (CC)\n*/\n/* global Highcharts window document module:true */\r\n/**\r\n * @fileoverview\r\n * @suppress {checkTypes}\r\n */\r\n(function (factory) {\r\n\tif (typeof module === 'object' && module.exports) {\r\n\t\tmodule.exports = factory;\r\n\t} else {\r\n\t\tfactory(Highcharts);\r\n\t}\r\n}(function (H) {\r\n\tvar each = H.each,\r\n\t\tseriesTypes = H.seriesTypes,\r\n\t\tpick = H.pick,\r\n\t\tUNDEFINED,\r\n\t\tNORMAL_STATE = '',\r\n\t\tVISIBLE = 'visible',\r\n\t\tHIDDEN = 'hidden',\r\n\t\tPREFIX = 'highcharts-',\r\n\t\tNONE = 'none',\r\n\t\thasTouch = document.documentElement.ontouchstart !== UNDEFINED,\r\n\t\tTRACKER_FILL = 'rgba(192,192,192,' + (H.hasSVG ? 0.0001 : 0.002) + ')', // invisible but clickable\r\n\t\tM = 'M',\r\n\t\tL = 'L';\r\n\t\r\n\t// handle unsorted data, throw error anyway\r\n\tfunction error(code, stop) {\r\n\t\tvar msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\r\n\t\tif (stop) {\r\n\t\t\tthrow msg;\r\n\t\t} else if (window.console) {\r\n\t\t\tconsole.log(msg); // eslint-disable-line\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\tIf replacing L and M in tracker will be necessary use that getPath():\r\n\t\r\n\tfunction getPath(arr){\r\n\tvar ret = [];\r\n\teach(arr, function(el, ind) {\r\n\tvar len = el[0].length;\r\n\tfor(var i = 0; i < len; i++){\r\n\tvar p = el[0][i];\r\n\tif(p == M && ind != 0 && i == 0) {\r\n\tp = L;\r\n\t}\r\n\tret.push(p);\r\n\t}\r\n\t});\r\n\treturn ret;\r\n\t}\r\n\t**/\r\n\t\r\n\t\r\n\tfunction getPath(arr) {\r\n\t\tvar ret = [];\r\n\t\teach(arr, function (el) {\r\n\t\t\tret = ret.concat(el[0]);\r\n\t\t});\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/**\r\n\t * Return the graph path of a segment - compatibility with 4.2.3+\r\n\t * @param {Object} segment of the path\r\n\t * @returns {Array} Path (SVG)\r\n\t */\r\n\tH.Series.prototype.getSegmentPath = function (segment) {\r\n\t\tvar series = this,\r\n\t\t\tsegmentPath = [],\r\n\t\t\tstep = series.options.step;\r\n\r\n\t\t// build the segment line\r\n\t\teach(segment, function (point, i) {\r\n\t\t\tvar plotX = point.plotX,\r\n\t\t\t\tplotY = point.plotY,\r\n\t\t\t\tlastPoint;\r\n\r\n\t\t\tif (series.getPointSpline) {\r\n\t\t\t\t// generate the spline as defined in the SplineSeries object\r\n\t\t\t\tsegmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));\r\n\t\t\t} else {\r\n\t\t\t\t// moveTo or lineTo\r\n\t\t\t\tsegmentPath.push(i ? L : M);\r\n\r\n\t\t\t\t// step line?\r\n\t\t\t\tif (step && i) {\r\n\t\t\t\t\tlastPoint = segment[i - 1];\r\n\t\t\t\t\tif (step === 'right') {\r\n\t\t\t\t\t\tsegmentPath.push(\r\n\t\t\t\t\t\t\tlastPoint.plotX,\r\n\t\t\t\t\t\t\tplotY,\r\n\t\t\t\t\t\t\tL\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t} else if (step === 'center') {\r\n\t\t\t\t\t\tsegmentPath.push(\r\n\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\r\n\t\t\t\t\t\t\tlastPoint.plotY,\r\n\t\t\t\t\t\t\tL,\r\n\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\r\n\t\t\t\t\t\t\tplotY,\r\n\t\t\t\t\t\t\tL\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsegmentPath.push(\r\n\t\t\t\t\t\t\tplotX,\r\n\t\t\t\t\t\t\tlastPoint.plotY,\r\n\t\t\t\t\t\t\tL\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// normal line to next point\r\n\t\t\t\tsegmentPath.push(\r\n\t\t\t\t\tpoint.plotX,\r\n\t\t\t\t\tpoint.plotY\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn segmentPath;\r\n\t};\r\n\r\n\t/**\r\n\t*\r\n\t*   ColoredLine series type\r\n\t*\r\n\t**/\r\n\t\r\n\tseriesTypes.coloredline = H.extendClass(seriesTypes.line);\r\n\t\r\n\tH.seriesTypes.coloredline.prototype.processData = function (force) {\r\n\t\tvar series = this,\r\n\t\t\tprocessedXData = series.xData, // copied during slice operation below\r\n\t\t\tprocessedYData = series.yData,\r\n\t\t\tcropStart = 0,\r\n\t\t\tcropped,\r\n\t\t\tdistance,\r\n\t\t\tclosestPointRange,\r\n\t\t\txAxis = series.xAxis,\r\n\t\t\ti, // loop variable\r\n\t\t\toptions = series.options,\r\n\t\t\tisCartesian = series.isCartesian;\r\n\t\t\r\n\t\t// If the series data or axes haven't changed, don't go through this. Return false to pass\r\n\t\t// the message on to override methods like in data grouping.\r\n\t\tif (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// Find the closest distance between processed points\r\n\t\tfor (i = processedXData.length - 1; i >= 0; i--) {\r\n\t\t\tdistance = processedXData[i] - processedXData[i - 1];\r\n\t\t\tif (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\r\n\t\t\t\tclosestPointRange = distance;\r\n\t\t\t\t\r\n\t\t\t\t// Unsorted data is not supported by the line tooltip, as well as data grouping and\r\n\t\t\t\t// navigation in Stock charts (#725) and width calculation of columns (#1900)\r\n\t\t\t} else if (distance < 0 && series.requireSorting) {\r\n\t\t\t\terror(15);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Record the properties\r\n\t\tseries.cropped = cropped; // undefined or true\r\n\t\tseries.cropStart = cropStart;\r\n\t\tseries.processedXData = processedXData;\r\n\t\tseries.processedYData = processedYData;\r\n\t\t\r\n\t\tif (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC\r\n\t\t\tseries.pointRange = closestPointRange || 1;\r\n\t\t}\r\n\t\tseries.closestPointRange = closestPointRange;\r\n\t\treturn true;\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredline.prototype.drawTracker = function () {\r\n\t\tvar series = this,\r\n\t\t\toptions = series.options,\r\n\t\t\ttrackByArea = options.trackByArea,\r\n\t\t\ttrackerPath = [].concat(trackByArea ? series.areaPath : getPath(series.graphPath)),\r\n\t\t\ttrackerPathLength = trackerPath.length,\r\n\t\t\tchart = series.chart,\r\n\t\t\tpointer = chart.pointer,\r\n\t\t\trenderer = chart.renderer,\r\n\t\t\tsnap = chart.options.tooltip.snap,\r\n\t\t\ttracker = series.tracker,\r\n\t\t\tcursor = options.cursor,\r\n\t\t\tcss = cursor && { cursor: cursor },\r\n\t\t\tsinglePoints = series.singlePoints,\r\n\t\t\tsinglePoint,\r\n\t\t\ti,\r\n\t\t\tonMouseOver;\r\n\r\n\t\tonMouseOver = function () {\r\n\t\t\tif (chart.hoverSeries !== series) {\r\n\t\t\t\tseries.onMouseOver();\r\n\t\t\t}\r\n\t\t};\r\n\t\t// Extend end points. A better way would be to use round linecaps,\r\n\t\t// but those are not clickable in VML.\r\n\t\tif (trackerPathLength && !trackByArea) {\r\n\t\t\ti = trackerPathLength + 1;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (trackerPath[i] === M) { // extend left side\r\n\t\t\t\t\ttrackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\r\n\t\t\t\t}\r\n\t\t\t\tif ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\r\n\t\t\t\t\ttrackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// handle single points\r\n\t\tfor (i = 0; i < singlePoints.length; i++) {\r\n\t\t\tsinglePoint = singlePoints[i];\r\n\t\t\tif (singlePoint.plotX && singlePoint.plotY) {\r\n\t\t\t\ttrackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\r\n\t\t\t\t\tL, singlePoint.plotX + snap, singlePoint.plotY);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// draw the tracker\r\n\t\tif (tracker) {\r\n\t\t\ttracker.attr({ d: trackerPath });\r\n\t\t} else { // create\r\n\t\t\tseries.tracker = renderer.path(trackerPath)\r\n\t\t\t.attr({\r\n\t\t\t\t'stroke-linejoin': 'round', // #1225\r\n\t\t\t\tvisibility: series.visible ? VISIBLE : HIDDEN,\r\n\t\t\t\tstroke: TRACKER_FILL,\r\n\t\t\t\tfill: trackByArea ? TRACKER_FILL : NONE,\r\n\t\t\t\t'stroke-width': options.lineWidth + (trackByArea ? 0 : 2 * snap),\r\n\t\t\t\tzIndex: 2\r\n\t\t\t})\r\n\t\t\t.add(series.group);\r\n\t\t\t\r\n\t\t\t// The tracker is added to the series group, which is clipped, but is covered\r\n\t\t\t// by the marker group. So the marker group also needs to capture events.\r\n\t\t\teach([series.tracker, series.markerGroup], function (track) {\r\n\t\t\t\ttrack.addClass(PREFIX + 'tracker')\r\n\t\t\t\t.on('mouseover', onMouseOver)\r\n\t\t\t\t.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\r\n\t\t\t\t.css(css);\r\n\t\t\t\t\r\n\t\t\t\tif (hasTouch) {\r\n\t\t\t\t\ttrack.on('touchstart', onMouseOver);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredline.prototype.setState = function (state) {\r\n\t\tvar series = this,\r\n\t\t\toptions = series.options,\r\n\t\t\tgraph = series.graph,\r\n\t\t\tstateOptions = options.states,\r\n\t\t\tlineWidth = options.lineWidth,\r\n\t\t\tattribs;\r\n\t\t\r\n\t\tstate = state || NORMAL_STATE;\r\n\t\t\r\n\t\tif (series.state !== state) {\r\n\t\t\tseries.state = state;\r\n\t\t\t\r\n\t\t\tif (stateOptions[state] && stateOptions[state].enabled === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (state) {\r\n\t\t\t\tlineWidth = stateOptions[state].lineWidth || lineWidth + 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\r\n\t\t\t\tattribs = {\r\n\t\t\t\t\t'stroke-width': lineWidth\r\n\t\t\t\t};\r\n\t\t\t\t// use attr because animate will cause any other animation on the graph to stop\r\n\t\t\t\teach(graph, function (seg) {\r\n\t\t\t\t\tseg.attr(attribs);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t* The main change to get multi color isFinite changes segments array.\r\n\t* From array of points to object with color and array of points.\r\n\t* @returns {undefined}\r\n\t**/\r\n\tH.seriesTypes.coloredline.prototype.getSegments = function () {\r\n\t\tvar series = this,\r\n\t\t\tlastColor = 0,\r\n\t\t\tsegments = [],\r\n\t\t\ti,\r\n\t\t\tpoints = series.points,\r\n\t\t\tpointsLength = points.length;\r\n\t\t\r\n\t\tif (pointsLength) { // no action required for []\r\n\t\t\t\r\n\t\t\t// if connect nulls, just remove null points\r\n\t\t\tif (series.options.connectNulls) {\r\n\t\t\t\t// iterate backwars for secure point removal\r\n\t\t\t\tfor (i = pointsLength - 1; i >= 0; --i) {\r\n\t\t\t\t\tif (points[i].y === null) {\r\n\t\t\t\t\t\tpoints.splice(i, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tpointsLength = points.length;\r\n\t\t\t\t\r\n\t\t\t\teach(points, function (point, j) {\r\n\t\t\t\t\tif (j > 0 && points[j].segmentColor !== points[j - 1].segmentColor) {\r\n\t\t\t\t\t\tsegments.push({\r\n\t\t\t\t\t\t\tpoints: points.slice(lastColor, j + 1),\r\n\t\t\t\t\t\t\tcolor: points[j - 1].segmentColor\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tlastColor = j;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (pointsLength) {\r\n\t\t\t\t\t// add the last segment (only single-point last segement is added)\r\n\t\t\t\t\tif (lastColor !== pointsLength - 1) {\r\n\t\t\t\t\t\tsegments.push({\r\n\t\t\t\t\t\t\tpoints: points.slice(lastColor, pointsLength),\r\n\t\t\t\t\t\t\tcolor: points[pointsLength - 1].segmentColor\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (points.length && segments.length === 0) {\r\n\t\t\t\t\tsegments = [points];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// else, split on null points or different colors\r\n\t\t\t} else {\r\n\t\t\t\tvar previousColor = null;\r\n\t\t\t\teach(points, function (point, j) {\r\n\t\t\t\t\tvar colorChanged = j > 0 && (point.y === null || points[j - 1].y === null || (point.segmentColor !== points[j - 1].segmentColor && points[j].segmentColor !== previousColor)),\r\n\t\t\t\t\t\tcolorExists = points[j - 1] && points[j - 1].segmentColor && points[j - 1].y !== null ? true : false;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (colorChanged) {\r\n\t\t\t\t\t\tvar p = points.slice(lastColor, j + 1);\r\n\t\t\t\t\t\tif (p.length > 0) {\r\n\t\t\t\t\t\t\t// do not create segments with null ponits\r\n\t\t\t\t\t\t\teach(p, function (pointObject, k) {\r\n\t\t\t\t\t\t\t\tif (pointObject.y === null) {\r\n\t\t\t\t\t\t\t\t\t// remove null points (might be on edges)\r\n\t\t\t\t\t\t\t\t\tp.splice(k, 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tsegments.push({\r\n\t\t\t\t\t\t\t\tpoints: p,\r\n\t\t\t\t\t\t\t\tcolor: colorExists ? points[j - 1].segmentColor : previousColor\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tlastColor = j;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (j === pointsLength - 1) {\r\n\t\t\t\t\t\tvar next = j + 1;\r\n\t\t\t\t\t\tif (point.y === null) {\r\n\t\t\t\t\t\t\tnext--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tp = points.slice(lastColor, next);\r\n\t\t\t\t\t\tif (p.length > 0) {\r\n\t\t\t\t\t\t\t// do not create segments with null ponits\r\n\t\t\t\t\t\t\teach(p, function (pointObject, k) {\r\n\t\t\t\t\t\t\t\tif (pointObject.y === null) {\r\n\t\t\t\t\t\t\t\t\t// remove null points (might be on edges)\r\n\t\t\t\t\t\t\t\t\tp.splice(k, 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tsegments.push({\r\n\t\t\t\t\t\t\t\tpoints: p,\r\n\t\t\t\t\t\t\t\tcolor: colorExists ? points[j - 1].segmentColor : previousColor\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tlastColor = j;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// store previous color\r\n\t\t\t\t\tif (point) {\r\n\t\t\t\t\t\tpreviousColor = point.segmentColor;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t// register it\r\n\t\tseries.segments = segments;\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredline.prototype.getGraphPath = function () {\r\n\t\t// var ret = f.apply(this, Array.prototype.slice.call(arguments, 1));\r\n\t\tvar series = this,\r\n\t\t\tgraphPath = [],\r\n\t\t\tsegmentPath,\r\n\t\t\tsinglePoints = []; // used in drawTracker\r\n\t\t// Divide into segments and build graph and area paths\r\n\t\teach(series.segments, function (segment) {\r\n\t\t\tsegmentPath = series.getSegmentPath(segment.points);\r\n\t\t\t// add the segment to the graph, or a single point for tracking\r\n\t\t\tif (segment.points.length > 1) {\r\n\t\t\t\tgraphPath.push([segmentPath, segment.color]);\r\n\t\t\t} else {\r\n\t\t\t\tsinglePoints.push(segment.points);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// Record it for use in drawGraph and drawTracker, and return graphPath\r\n\t\tseries.singlePoints = singlePoints;\r\n\t\tseries.graphPath = graphPath;\r\n\t\t\r\n\t\treturn graphPath;\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredline.prototype.drawGraph = function () {\r\n\t\tvar series = this,\r\n\t\t\toptions = series.options,\r\n\t\t\tprops = [['graph', options.lineColor || series.color]],\r\n\t\t\tlineWidth = options.lineWidth,\r\n\t\t\tdashStyle = options.dashStyle,\r\n\t\t\troundCap = options.linecap !== 'square',\r\n\t\t\tgraphPath = series.getGraphPath(),\r\n\t\t\tgraphPathLength = graphPath.length,\r\n\t\t\tgraphSegmentsLength = 0;\r\n\t\t\r\n\t\tfunction getSegment(segment, prop, i) {\r\n\t\t\tvar attribs = {\r\n\t\t\t\t\tstroke: prop[1],\r\n\t\t\t\t\t'stroke-width': lineWidth,\r\n\t\t\t\t\tfill: 'none',\r\n\t\t\t\t\tzIndex: 1 // #1069\r\n\t\t\t\t},\r\n\t\t\t\titem;\r\n\t\t\tif (dashStyle) {\r\n\t\t\t\tattribs.dashstyle = dashStyle;\r\n\t\t\t} else if (roundCap) {\r\n\t\t\t\tattribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\r\n\t\t\t}\r\n\t\t\tif (segment[1]) {\r\n\t\t\t\tattribs.stroke = segment[1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\titem = series.chart.renderer.path(segment[0])\r\n\t\t\t.attr(attribs)\r\n\t\t\t.add(series.group);\r\n\r\n\r\n\t\t\tif (item.shadow) {\r\n\t\t\t\titem.shadow(!i && options.shadow);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn item;\r\n\t\t}\r\n\r\n\t\t// draw the graph\r\n\t\teach(props, function (prop, i) {\r\n\t\t\tvar graphKey = prop[0],\r\n\t\t\t\tgraph = series[graphKey],\r\n\t\t\t\tg;\r\n\t\t\t\r\n\t\t\tif (graph) { // cancel running animations, #459\r\n\t\t\t\t// do we have animation\r\n\t\t\t\teach(graphPath, function (segment, j) {\r\n\t\t\t\t\t// update color and path\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (series[graphKey][j]) {\r\n\t\t\t\t\t\tseries[graphKey][j].attr({ d: segment[0], stroke: segment[1] });\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseries[graphKey][j] = getSegment(segment, prop, i);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t} else if (graphPath.length) { // #1487\r\n\t\t\t\tgraph = [];\r\n\t\t\t\teach(graphPath, function (segment, j) {\r\n\t\t\t\t\tgraph[j] = getSegment(segment, prop, i);\r\n\t\t\t\t});\r\n\t\t\t\tseries[graphKey] = graph;\r\n\t\t\t\t// add destroying elements\r\n\t\t\t\tseries[graphKey].destroy = function () {\r\n\t\t\t\t\tfor (g in series[graphKey]) {  // eslint-disable-line\r\n\t\t\t\t\t\tvar el = series[graphKey][g];\r\n\t\t\t\t\t\tif (el && el.destroy) {\r\n\t\t\t\t\t\t\tel.destroy();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t// Checks if series.graph exists. #3\r\n\t\t\tgraphSegmentsLength = (series.graph && series.graph.length) || -1;\r\n\t\t\t\r\n\t\t\tfor (var j = graphSegmentsLength; j >= graphPathLength; j--) {\r\n\t\t\t\tif (series[graphKey][j]) {\r\n\t\t\t\t\tseries[graphKey][j].destroy();\r\n\t\t\t\t\tseries[graphKey].splice(j, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tH.wrap(seriesTypes.coloredline.prototype, 'translate', function (proceed) {\r\n\t\tproceed.apply(this, [].slice.call(arguments, 1));\r\n\t\tif (this.getSegments) {\r\n\t\t\tthis.getSegments();\r\n\t\t}\r\n\t});\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t*\r\n\t*   ColoredArea series type\r\n\t*\r\n\t**/\r\n\tseriesTypes.coloredarea = H.extendClass(seriesTypes.coloredline);\r\n\t\r\n\tH.seriesTypes.coloredarea.prototype.init = function (chart, options) {\r\n\t\toptions.threshold = options.threshold || null;\r\n\t\tH.Series.prototype.init.call(this, chart, options);\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredarea.prototype.closeSegment = function (path, segment, translatedThreshold) {\r\n\t\tpath.push(\r\n\t\t\tL,\r\n\t\t\tsegment[segment.length - 1].plotX,\r\n\t\t\ttranslatedThreshold,\r\n\t\t\tL,\r\n\t\t\tsegment[0].plotX,\r\n\t\t\ttranslatedThreshold\r\n\t\t);\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredarea.prototype.drawGraph = function (f) {\r\n\t\tH.seriesTypes.coloredline.prototype.drawGraph.call(this, f);\r\n\t\tvar series = this,\r\n\t\t\toptions = this.options,\r\n\t\t\tprops = [['graph', options.lineColor || series.color]];\r\n\r\n\t\teach(props, function (prop) {\r\n\t\t\tvar graphKey = prop[0],\r\n\t\t\t\tgraph = series[graphKey];\r\n\t\t\t\r\n\t\t\tif (graph) { // cancel running animations, #459\r\n\t\t\t\t// do we have animation\r\n\t\t\t\teach(series.graphPath, function (segment, j) {\r\n\t\t\t\t\t// update color and path\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (series[graphKey][j]) {\r\n\t\t\t\t\t\tseries[graphKey][j].attr({ fill: segment[1] });\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t/**\r\n\t* Extend the base Series getSegmentPath method by adding the path for the area.\r\n\t* This path is pushed to the series.areaPath property.\r\n\t* @param {Object} segment of the path\r\n\t* @returns {Array} Path (SVG)\r\n\t**/\r\n\tH.seriesTypes.coloredarea.prototype.getSegmentPath = function (segment) {\r\n\t\tvar segmentPath = H.Series.prototype.getSegmentPath.call(this, segment), // call base method\r\n\t\t\tareaSegmentPath = [].concat(segmentPath), // work on a copy for the area path\r\n\t\t\ti,\r\n\t\t\toptions = this.options,\r\n\t\t\tsegLength = segmentPath.length,\r\n\t\t\ttranslatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181\r\n\t\t\tyBottom;\r\n\r\n\t\tif (segLength === 3) { // for animation from 1 to two points\r\n\t\t\tareaSegmentPath.push(L, segmentPath[1], segmentPath[2]);\r\n\t\t}\r\n\t\tif (options.stacking && !this.closedStacks) {\r\n\t\t\tfor (i = segment.length - 1; i >= 0; i--) {\r\n\r\n\t\t\t\tyBottom = pick(segment[i].yBottom, translatedThreshold);\r\n\r\n\t\t\t\t// step line?\r\n\t\t\t\tif (i < segment.length - 1 && options.step) {\r\n\t\t\t\t\tareaSegmentPath.push(segment[i + 1].plotX, yBottom);\r\n\t\t\t\t}\r\n\t\t\t\tareaSegmentPath.push(segment[i].plotX, yBottom);\r\n\t\t\t}\r\n\t\t} else { // follow zero line back\r\n\t\t\tthis.closeSegment(areaSegmentPath, segment, translatedThreshold);\r\n\t\t}\r\n\t\treturn areaSegmentPath;\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredarea.prototype.getGraphPath = function () {\r\n\t\tvar series = this,\r\n\t\t\tgraphPath = [],\r\n\t\t\tsegmentPath,\r\n\t\t\tsinglePoints = []; // used in drawTracker\r\n\t\t// Divide into segments and build graph and area paths\r\n\t\t\r\n\t\tthis.areaPath = [];\r\n\t\teach(series.segments, function (segment) {\r\n\t\t\tsegmentPath = series.getSegmentPath(segment.points);\r\n\t\t\t// add the segment to the graph, or a single point for tracking\r\n\t\t\tif (segment.points.length > 1) {\r\n\t\t\t\tgraphPath.push([segmentPath, segment.color]);\r\n\t\t\t} else {\r\n\t\t\t\tsinglePoints.push(segment.points);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// Record it for use in drawGraph and drawTracker, and return graphPath\r\n\t\tseries.singlePoints = singlePoints;\r\n\t\tseries.graphPath = graphPath;\r\n\t\treturn graphPath;\r\n\t\r\n\t};\r\n\t\r\n\tH.seriesTypes.coloredarea.prototype.drawLegendSymbol = H.LegendSymbolMixin.drawRectangle;\r\n}));"]}